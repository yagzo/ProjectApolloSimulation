#!/usr/bin/env python3.7

#from params_ternary import create_param
from onebedmulticomponent import purity_recovery
from onebedmulticomponent import plot_data
from isothermfit import getisothermparam
import numpy as np
import util
import pickle
import os

#P=[1,2,3,4,5]
#Pz0=0
#PzL=6
#jplus5,jminus5 = gen_j5_functions()
#Pplus5= jplus5(P,Pz0,PzL)
#print(Pplus5, np.shape(Pplus5))
#Pmiuns5= jminus5(P,Pz0, PzL)
#print(Pmiuns5, np.shape(Pmiuns5))
#dplus = diffplus(P,PzL)
#print(dplus)
#dminus = diffminus(P,Pz0)
#print(dminus)

#import params_benchmark
#param = params_benchmark.create_param(None)

#bunch, status = cyclic_steady_state(localparam)
#with open('statusdatabenchmark.pickle', 'wb') as f:
#    # Pickle the 'data' dictionary using the highest protocol available.
#    pickle.dump(status, f, pickle.HIGHEST_PROTOCOL)

#status= util.loadpickle('/mnt/c/Simulation/ProjectApolloSimulation/simulation/multicomponentPSA/statusdatabenchmark.pickle')

#bunch = status.snap[status.cycle]

#plot_data(bunch,status.param,'./TJT/TJT')
#print(purity_recovery(bunch,status.param))

#print(bunch.t, np.shape(bunch.t))
#print(status.param)
#param = create_param(None)
#plot_data(bunch, param ,'./outcome')



##test integral  of discrete variable over given time span###
#mole =purity_recovery(bunch,status.param)
#print(mole)



###test isothermfitting
#iso

#print(isothermdict)

### optimization 

from onebedmulticomponent import PSA_optimization
from pymoo.algorithms.moo.nsga2 import NSGA2
from pymoo.factory import get_sampling, get_crossover, get_mutation
from pymoo.factory import get_termination
from pymoo.optimize import minimize

from pymoo.core.problem import starmap_parallelized_eval

import multiprocessing


isothermdatabase=util.loadpickle(os.path.join(os.getcwd(),'graph','LangmuirIsotherm.pickle')) # load the isotherm database
mofdict=getisothermparam(isothermdatabase,'NEXXEV',["C2H2","ethene","ethane"])

n_proccess = 8 # the number of processes to be used
pool = multiprocessing.Pool(n_proccess)



### simulation
#problem = PSA_optimization(runner=pool.starmap, func_eval=starmap_parallelized_eval)
#bunch, status = problem.css_simulate()
#problem.plot()

### simulation of 6-step DRPSA
problem = PSA_optimization(bedmodel="DRPSA",runner=pool.starmap, func_eval=starmap_parallelized_eval)
bunch, status = problem.css_simulate()
problem.plot()

### optimization
# algorithm = NSGA2(
#     pop_size=40,
#     n_offsprings=10,
#     sampling=get_sampling("real_random"),
#     crossover=get_crossover("real_sbx", prob=0.9, eta=15),
#     mutation=get_mutation("real_pm", eta=20),
#     eliminate_duplicates=True
# )

# termination = get_termination("n_gen", 40)

# res = minimize(problem,
#                algorithm,
#                termination,
#                seed=1,
#                save_history=True,
#                verbose=True)

# util.saveaspickle(problem.optfilepickle,res)


#optimization analysis
#problem.optanalysis()

